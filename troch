#!/usr/bin/python3
#+
# Generate epitrochoid and hypotrochoid patterns using various graphics systems.
# For background, see <https://en.wikipedia.org/wiki/Spirograph>,
# <https://en.wikipedia.org/wiki/Epitrochoid> and <https://en.wikipedia.org/wiki/Hypotrochoid>.
# Invoke this script as follows:
#
#     troch [options] curvespec [curvespec...]
#
# where the valid options are
#
#     --draw=drawspec (required)
#         specifies how to do the drawing. The drawspec looks like
#             drawtype[:drawoption[:drawoption..]]
#        where drawtype is one of
#             cairo      -- use Cairo graphics to output a PNG image file.
#             postscript -- output PostScript drawing commands.
#             turtle     -- draw onscreen using Turtle graphics.
#        and the drawoptions are drawtype-specific.
#
#        For the cairo drawtype, the drawoptions are:
#            out=filename (required)
#                specifies a filename to write the PNG image data to.
#            scale=f
#                an overall scale factor to apply to the drawing.
#
#        For the postscript drawtype, the drawoptions are:
#            out=filename
#                specifies a filename to write the PostScript to. If not specified,
#                it goes to standard output.
#            scale=f
#                an overall scale factor to apply to the drawing.
#
#        For the turtle drawtype, the drawoptions are:
#            hideturtle
#                hide the turtle to speed up drawing.
#            speed=speed
#                speed of turtle movement.
#            trackheading
#                causes the turtle to always face in the direction it is moving.
#                Slows down the drawing, which is why it’s not the default.
#
#     --bgcolor/bgcolour=colourspec
#            specifies the background colour to set before doing drawing.
#     --size=w:h
#            specifies the size of the drawing area.
#
# Each curvespec specifies the parameters for a curve to draw, and takes the form
#
#     keyword=value:keyword=value...
#
# where the valid keywords are
#
#     pencolor/pencolour
#         specifies the pen colour to use to draw the curve. Defaults to the
#         same as the previous curve, or black for the first curve.
#     pensize
#         specifies the width of the curve. Defaults to the same as the previous
#         curve, or 1 for the first curve.
#     ring (required)
#         specifies the relative radius of the stationary circle.
#     wheel (required)
#         specifies the relative radius of the moving circle.
#     scale
#         a scale factor applied to the ring and wheel values to determine the
#         actual radii. Separating this out allows small numbers to be used
#         for the other two, making their relative factor relationships easier
#         to see.
#     frac (required)
#         specifies the fraction of the wheel radius from the centre of the wheel
#         at which the point is located that traces out the curve.
#     nrsteps (required)
#         the number of straight-line segments that make up the complete curve.
#         A larger number makes for a more accurate (smoother) curve, at the
#         expense of greater drawing time.
#     phase
#         optional starting phase angle in degrees for this pattern. If omitted,
#         defaults to 0.
#
# Written by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
#-

import sys
import math
from fractions import \
    Fraction
import cairo
from turtle import \
    Vec2D
import getopt

#+
# Useful stuff
#-

def parse_color_opt(colorstr) :
    if colorstr.find(",") >= 0 :
        pen_color = tuple(float(i) for i in colorstr.split(",", 2))
    elif colorstr.startswith("#") :
        assert (len(colorstr) - 1) % 3 == 0, "invalid HTML colour spec"
        seglen = (len(colorstr) - 1) // 3
        pen_color = tuple \
          (
            int(colorstr[i * seglen + 1 : (i + 1) * seglen + 1], 16) / ((1 << seglen * 4) - 1)
            for i in (0, 1, 2)
          )
    else :
        pen_color = colorstr # assume it’s a colour name
    #end if
    return pen_color
#end parse_color_opt

color_names = {} # mapping of traditional X11 colour names to (r, g, b) tuples

def load_color_names() :
    for line in open("/usr/share/X11/rgb.txt", "r") :
        if not line.startswith("!") :
            line = line.strip()
            for junk in ("\t", "  ") :
                while True :
                    line2 = line.replace(junk, " ")
                    if line2 == line :
                        break
                    line = line2
                #end while
            #end for
            r, g, b, name = line.split(" ", 3)
            r, g, b = int(r), int(g), int(b)
            color_names[name.lower()] = (r / 255, g / 255, b / 255)
        #end if
    #end line
#end load_color_names
load_color_names()
del load_color_names

def parse_color_args(args) :
    if len(args) == 1 and type(args[0]) == str :
        newcolor = color_names[args[0]]
    elif len(args) == 1 and type(args[0]) == tuple and len(args[0]) == 3 :
        newcolor = args[0]
    elif len(args) == 3 :
        newcolor = args
    else :
        raise TypeError("invalid colour specification")
    #end if
    return newcolor
#end parse_color_args

#+
# Drawing classes
#-

class Drawer :
#+
# Subclasses should define the following methods:
#
# opt_xxx
#     defines a command-line option xxx (for whatever xxx you like) to be specified
#     following the drawtype. Can take one or no arguments.
#
# setsize(w, h)
#     sets the dimensions of the drawing area.
#
# bgcolor(c)
#     clears the background to the specified colour. See pencolor, below, for valid
#     values for c.
#
# donesetup()
#     will be called exactly once. Indicates that no further calls to setsize or
#     bgcolor will be done.
#
# pensize(w)
#     sets the pensize for subsequent drawing to w.
#
# pencolor(c)
#     sets the pen colour for subsequent to c, which can be an X11 colour name, or a tuple
#     of 3 values (r, g, b) in [0 .. 1], or 3 separate args r, g, b in [0 .. 1].
#
# penup()
#     stops subsequent pen movements from drawing any lines.
#
# pendown()
#     resumes drawing lines on subsequent pen movements.
#
# setpos(p)
#     moves the pen to the specified position, which can be a Vec2D, or 2 separate x and y
#     arguments.
#
# done()
#     called at the end of drawing.
#-
    pass

#end Drawer

class CairoDrawer(Drawer) :

    def __init__(self) :
        self.size = None
        self.bg_color = (1, 1, 1)
        self.pen_color = (0, 0, 0)
        self.pen_size = 1
        self.scale_factor = 1.0
        self.outfilename = None
    #end __init__

    def opt_out(self, filename) :
        self.outfilename = filename
    #end opt_out

    def opt_scale(self, factor) :
        self.scale_factor = float(factor)
    #end opt_scale

    def setsize(self, newsize) :
        self.size = newsize
    #end setsize

    def bgcolor(self, *args) :
        self.bg_color = parse_color_args(args)
    #end bgcolor

    def donesetup(self) :
        assert self.size != None, "forgot to set drawing size"
        assert self.outfilename != None, "forgot to set output filename"
        self.pix = cairo.ImageSurface \
          (
            cairo.FORMAT_RGB24, # format
            self.size[0], # width
            self.size[1] # height
          )
        self.g = cairo.Context(self.pix)
        self.g.set_operator(cairo.OPERATOR_SOURCE)
        self.g.translate(self.size[0] / 2, self.size[1] / 2)
        self.g.scale(self.scale_factor, self.scale_factor)
        self.g.set_source_rgb(*self.bg_color)
        self.g.paint()
        self.g.new_path()
        self.g.move_to(0, 0)
        self.inpath = True
        self.drawing = True
    #end donesetup

    def pensize(self, newsize) :
        self.pen_size = newsize
    #end pensize

    def pencolor(self, *args) :
        self.pen_color = parse_color_args(args)
    #end pencolor

    def penup(self) :
        self.finishpath()
        self.drawing = False
    #end penup

    def pendown(self) :
        self.drawing = True
    #end pendown

    def setpos(self, newpos) :
        self.startpath()
        (self.g.move_to, self.g.line_to)[self.drawing](newpos[0], newpos[1])
    #end setpos

    def startpath(self) :
        if not self.inpath :
            self.g.new_path()
            self.g.set_source_rgb(*self.pen_color)
            self.g.set_line_width(self.pen_size)
            self.inpath = True
        #end if
    #end startpath

    def finishpath(self) :
        if self.inpath :
            self.g.stroke()
        #end if
        self.inpath = False
    #end finishpath

    def done(self) :
        self.finishpath()
        self.pix.flush()
        self.g = None
        self.pix.write_to_png(self.outfilename)
        self.pix = None
    #end done

#end CairoDrawer

class PostScriptDrawer(Drawer) :

    def __init__(self) :
        self.w = sys.stdout.write
        self.out = None
        self.nrpoints = 0
        self.drawing = True
        self.currentpoint = None
    #end __init__

    def opt_scale(self, factor) :
        factor = float(factor)
        self.w("%.3f %.3f scale\n" % (factor, factor))
    #end opt_scale

    def opt_out(self, filename) :
        self.out = open(filename, "w")
        self.w = self.out.write
    #end opt_out

    def setsize(self, newsize) :
        self.w \
          (
                "<<\n"
                "    /ImageBBox 0 0 %(width).3f %(height).3f\n"
                "    /PageSize %(width).3f %(height).3f\n"
                ">> setpagedevice\n"
            %
                {"width" : newsize[0], "height" : newsize[1]}
          )
    #end setsize

    def bgcolor(self, *args) :
        self.w("currentcolor currentcolorspace\n")
        self.w("%.3f %.3f %.3f setrgbcolor\n" % parse_color_args(args))
        self.w("clippath fill\nsetcolorspace setcolor\n")
    #end bgcolor

    def donesetup(self) :
        self.w \
          (
            "clippath pathbbox\n"
            "exch 4 3 roll sub 2 div\n" # x offset
            "3 1 roll exch sub 2 div\n" # y offset
            "translate\n" # move origin to centre
          )
    #end donesetup

    def pensize(self, newsize) :
        self.finishpath()
        self.w("%.1f setlinewidth\n" % newsize)
    #end pensize

    def pencolor(self, *args) :
        self.finishpath()
        self.w("%.3f %.3f %.3f setrgbcolor\n" % parse_color_args(args))
    #end pencolor

    def penup(self) :
        self.finishpath()
        self.drawing = False
    #end penup

    def pendown(self) :
        self.drawing = True
    #end pendown

    def setpos(self, newpos) :
        x, y = newpos[0], newpos[1]
        if self.nrpoints == 500 : # actually level 2 and later have no limit? 
            self.finishpath()
        #end if
        if self.nrpoints == 0 :
            self.w("newpath\n")
            if self.drawing :
                if self.currentpoint == None :
                    self.w("0 0 moveto\n")
                else :
                    self.w("%.1f %.1f moveto\n" % (self.currentpoint[0], self.currentpoint[1]))
                #end if
            #end if
        #end if
        self.w("%.1f %.1f %s\n" % (x, y, ("moveto", "lineto")[self.drawing]))
        self.nrpoints += 1
        self.currentpoint = Vec2D(x, y)
    #end setpos

    def finishpath(self) :
        if self.nrpoints != 0 :
            self.w("stroke\n")
            self.nrpoints = 0
        #end if
    #end finishpath

    def done(self) :
        self.finishpath()
        self.w("showpage\n")
        if self.out != None :
            self.out.flush()
            self.out.close()
        #end if
    #end done

#end PostScriptDrawer

class TurtleDrawer(Drawer) :

    def __init__(self) :
        import turtle
        self.t = turtle
        for \
            method \
        in \
            ("bgcolor", "pensize", "pencolor", "penup", "pendown",) \
        :
            setattr(self, method, getattr(self.t, method))
        #end for
        self.track_heading = False
    #end __init__

    def opt_speed(self, newspeed) :
        try :
            speedval = int(newspeed)
        except ValueError :
            speedval = newspeed
        #end try
        self.t.speed(speedval)
    #end opt_speed

    def opt_hideturtle(self) :
        self.t.hideturtle()
    #end opt_hideturtle

    def opt_trackheading(self) :
        self.track_heading = True
    #end opt_trackheading

    def setsize(self, newsize) :
        w, h = newsize[0], newsize[1]
        self.t.screensize(w, h)
        self.t.setup(width = w, height = h)
    #end setsize

    def donesetup(self) :
        pass
    #end donesetup

    def setpos(self, newpos) :
        if self.track_heading and self.t.isvisible() :
            prevpos = self.t.position()
            self.t.setheading \
              (
                math.degrees(math.atan2(newpos[1] - prevpos[1], newpos[0] - prevpos[0]))
              )
        #end if
        self.t.setpos(newpos)
    #end setpos

    def done(self) :
        self.t.hideturtle()
        self.t.exitonclick()
    #end done

#end TurtleDrawer

drawtypes = \
    {
        "cairo" : CairoDrawer,
        "postscript" : PostScriptDrawer,
        "turtle" : TurtleDrawer,
    }

#+
# Mainline
#-

(opts, args) = getopt.getopt \
  (
    sys.argv[1:],
    "",
    ["bgcolor=", "bgcolour=", "draw=", "size="]
  )
drawtype = None
bgcolor = None
drawsize = None
for keyword, value in opts :
    if keyword == "--bgcolor" or keyword == "--bgcolour" :
        bgcolor = parse_color_opt(value)
    elif keyword == "--draw" :
        items = value.split(":")
        if drawtype != None :
            raise getopt.GetoptError("only one --draw opt allowed")
        #end if
        drawtype = drawtypes[items[0]]
        t = drawtype()
        for item in items[1:] :
            value = item.split("=", 1)
            if len(value) == 2 :
                keyword, optargs = value[0], (value[1],)
            else :
                keyword, optargs = value[0], ()
            #end if
            opt_method = "opt_" + keyword
            assert hasattr(t, opt_method), "%s drawtype has no option %s" % (items[0], keyword)
            getattr(t, opt_method)(*optargs)
        #end for
    elif keyword == "--size" :
        items = value.split(":", 1)
        drawsize = Vec2D(int(items[0]), int(items[1]))
    #end if
#end for
if drawtype == None :
    raise getopt.GetoptError("missing --draw opt")
#end if
if drawsize != None :
    t.setsize(drawsize)
#end if
if bgcolor != None :
    t.bgcolor(bgcolor)
#end if
t.donesetup()
for arg in args :
    # note pen_color and pen_size default to settings for previous curve, if any
    pen_color = None
    pen_size = None
    ring_radius = None
    wheel_radius = None
    scale = 1
    wheel_frac = None
    nr_steps = None
    phase = 0
    for item in arg.split(":") :
        keyword, value = item.split("=", 1)
        if keyword == "frac" :
            wheel_frac = float(value)
        elif keyword == "nrsteps" :
            nr_steps = int(value)
        elif keyword == "pencolor" or keyword == "pencolour" :
            pen_color = parse_color_opt(value)
        elif keyword == "pensize" :
            pen_size = float(value)
        elif keyword == "phase" :
            phase = float(value)
        elif keyword == "ring" :
            ring_radius = int(value)
        elif keyword == "scale" :
            scale = float(value)
        elif keyword == "wheel" :
            wheel_radius = int(value)
        else :
            raise getopt.GetoptError("invalid curve keyword %s" % keyword)
        #end if
    #end for
    # wheel_radius is +ve for epitrochoid, -ve for hypotrochoid
    if (
            None in (ring_radius, wheel_radius, wheel_frac, nr_steps)
        or
            wheel_radius + ring_radius == 0
        or
            nr_steps <= 0
    ) :
        raise getopt.GetoptError("invalid or missing curve parameters")
    #end if
    ratio = Fraction(ring_radius, wheel_radius)
    nr_cycles = ratio.denominator # to produce one complete traversal of curve

    if pen_color != None :
        t.pencolor(pen_color)
    #end if
    if pen_size != None :
        t.pensize(pen_size)
    #end if
    t.penup() # for first point
    for i in range(0, nr_steps + 1) :
        theta_ring = 360 * nr_cycles * i / nr_steps
        theta_wheel = theta_ring * (ring_radius / wheel_radius + 1)
        wheel_pos = Vec2D((ring_radius + wheel_radius) * scale, 0).rotate(theta_ring + phase)
        curve_pos = wheel_pos + Vec2D(wheel_radius * scale * wheel_frac, 0).rotate(theta_wheel)
        t.setpos(curve_pos)
        t.pendown() # for subsequent points
    #end for
#end for
t.done()
