#!/usr/bin/python3
#+
# Generate various types of curves using various graphics systems.
# Invoke this script as follows:
#
#     curve [options] curvespec [curvespec...]
#
# where the valid options are
#
#     --draw=drawspec (required)
#         specifies how to do the drawing. The drawspec looks like
#             drawtype[:drawoption[:drawoption..]]
#        where drawtype is one of
#             cairo      -- use Cairo graphics to output a PNG image file.
#             postscript -- output PostScript drawing commands.
#             turtle     -- draw onscreen using Turtle graphics.
#        and the drawoptions are drawtype-specific.
#
#        For the cairo drawtype, the drawoptions are:
#            out=filename (required)
#                specifies a filename to write the PNG image data to.
#            scale=f
#                an overall scale factor to apply to the drawing.
#
#        For the postscript drawtype, the drawoptions are:
#            out=filename
#                specifies a filename to write the PostScript to. If not specified,
#                it goes to standard output.
#            scale=f
#                an overall scale factor to apply to the drawing.
#
#        For the turtle drawtype, the drawoptions are:
#            hideturtle
#                hide the turtle to speed up drawing.
#            speed=ratio
#                set relative speed of turtle movement.
#            trackheading
#                causes the turtle to always face in the direction it is moving.
#                Slows down the drawing, which is why it’s not the default.
#
#     --bgcolor/bgcolour=colourspec
#            specifies the background colour to set before doing drawing.
#     --nrsteps=nrsteps
#            optionally specify a default nrsteps value for curvespecs that
#            do not specify their own.
#     --size=w:h
#            specifies the size of the drawing area. Note this mandatory
#            for the Cairo drawtype.
#
# Each curvespec specifies the parameters for a curve to draw, and takes the form
#
#     curvetype:keyword=value:keyword=value...
#
# where the curvetype specifies the general class of curve to draw, and the
# keyword-value pairs specify parameters defining the exact curve to draw. Some
# keywords are specific to the curve type, whereas others are common across
# curve types. If curvetype is the empty string, then it defaults to the same
# curvetype and same settings as the previous curvespec (this is not allowed for
# the first curvespec).
#
# Keywords that are valid across all curve types are:
#
#     pencolor/pencolour
#         specifies the pen colour to use to draw the curve. Defaults to the
#         same as the previous curve, or black for the first curve.
#     pensize
#         specifies the width of the curve. Defaults to the same as the previous
#         curve, or 1 for the first curve.
#     nrsteps (required unless --nrsteps is specified)
#         the integer number of straight-line segments that make up the complete
#         curve. A larger number makes for a more accurate (smoother) curve, at
#         the expense of greater drawing time.
#
# The currently-valid curve types are:
#     lissa -- Lissajous curve
#     rose -- rose curve
#     troch -- trochoid curve
#
# Valid keywords specific to the lissa curve type are:
#     x_amp (required)
#        amplitude of curve along x-axis
#     x_freq (required)
#        frequency of curve along x-axis
#     x_phase
#        phase of curve along x-axis, defaults to 0
#     y_amp (required)
#        amplitude of curve along y-axis
#     y_freq (required)
#        frequency of curve along y-axis
#     y_phase
#        phase of curve along y-axis, defaults to 0
#
# Valid keywords specific to the rose curve type are:
#     amplitude (required)
#        amplitude of the sine wave, the main parameter governing the size of the curve
#     freq
#        an integer or a ratio of two integers a/b that define the frequency of the sine wave.
#     offset
#        an optional value to offset the centre of the wave from the centre of the
#        pattern. Defaults to 0.
#     phase
#        a phase angle for rotating the curve. Defaults to 0.
#
# Valid keywords specific to the troch curve type are:
#     ring (required)
#         specifies the relative radius of the stationary circle. Must be an
#         integer
#     wheel (required)
#         specifies the relative radius of the moving circle. Must be an integer
#     scale
#         a scale factor applied to the ring and wheel values to determine the
#         actual radii. Separating this out allows small numbers to be used
#         for the other two, making their relative factor relationships easier
#         to see.
#     frac (required)
#         specifies the fraction of the wheel radius from the centre of the wheel
#         at which the point is located that traces out the curve.
#     phase
#         optional starting phase angle in degrees for this pattern. If omitted,
#         defaults to 0.
#
# A colour specification can take the following forms:
#     * a colour name from the list in /usr/share/X11/rgb.txt
#     * three colour components, each in the range [0, 1] separated by commas,
#       optionally preceded by a colour space specification and another comma:
#           <r>,<g>,<b>
#           rgb,<r>,<g>,<b>
#           hsv,<h>,<s>,<v>
#       Currently-recognized colour spaces are "rgb" and "hsv", with "rgb" being
#       the default if not specified.
#
# Examples:
#
#     curve --draw=turtle:hideturtle:speed=2 \
#         lissa:x_amp=200:y_amp=200:x_freq=3:y_freq=2:nrsteps=200:x_phase=-.2:pensize=4
#
# draws a Lissajous curve on-screen, animating at twice normal speed.
#
#     curve --draw=cairo:out=try.png --size=700:700 \
#         rose:amplitude=300:freq=7/2:pensize=8:nrsteps=300:offset=30
#
# draws a rose curve and saves the image into the file try.png.
#
#     curve --draw=postscript:out=try.ps --bgcolor=lavender \
#         troch:ring=17:wheel=-6:scale=10:frac=3:nrsteps=500:pensize=12:pencolor=orange
#
# generates PostScript code for filling the background with a lavender colour, and drawing
# a trochoid curve on top of it, into the file try.ps.
#
#     curve --draw=turtle --bgcolor=hsv,0.67,.08,.98 \
#         troch:ring=17:wheel=-6:scale=10:frac=3:nrsteps=500:pensize=12:pencolor=hsv,.11,1,1
#
# does the same trochoid curve as the previous example, specifying the colours in HSV
# form.
#
# Copyright 2014, 2016 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY-SA <http://creativecommons.org/licenses/by-sa/4.0/>.
#-

import sys
import math
from fractions import \
    Fraction, \
    gcd
import colorsys
import qahirah as qah
from qahirah import \
    CAIRO, \
    Colour, \
    Vector
import getopt

#+
# Useful stuff
#-

def parse_ratio(ratiostr) :
    "parses ratiostr as a single integer, or as two integers separated by a" \
    " slash: a/b representing a ratio. returns a Fraction object representing" \
    " the value in either case."
    splitpos = ratiostr.find("/")
    if splitpos >= 0 :
        numer, denom = int(ratiostr[:splitpos]), int(ratiostr[splitpos + 1:])
    else :
        numer = int(ratiostr)
        denom = 1
    #end if
    return \
        Fraction(numer, denom)
#end parse_ratio

def parse_color_opt(colorstr) :
    if colorstr.find(",") >= 0 :
        items = colorstr.split(",")
        if len(items) == 4 :
            space = items[0].lower()
            items = items[1:]
        elif len(items) == 3 :
            space = "rgb"
        else :
            raise ValueError("colour spec must be [space,]comp1,comp2,comp3")
        #end if
        pen_color = \
            (
                {
                    "hsv" : colorsys.hsv_to_rgb,
                    "rgb" : lambda r, g, b : (r, g, b),
                }[space](*tuple(float(i) for i in items))
            )
    elif colorstr.startswith("#") :
        assert (len(colorstr) - 1) % 3 == 0, "invalid HTML colour spec"
        seglen = (len(colorstr) - 1) // 3
        pen_color = tuple \
          (
            int(colorstr[i * seglen + 1 : (i + 1) * seglen + 1], 16) / ((1 << seglen * 4) - 1)
            for i in (0, 1, 2)
          )
    else :
        pen_color = colorstr # assume it’s a colour name
    #end if
    return pen_color
#end parse_color_opt

def parse_color_args(args) :
    if len(args) == 1 and type(args[0]) == str :
        newcolor = tuple(Colour.x11[args[0]])[:3]
    elif len(args) == 1 and type(args[0]) == tuple and len(args[0]) == 3 :
        newcolor = args[0]
    elif len(args) == 3 :
        newcolor = args
    else :
        raise TypeError("invalid colour specification")
    #end if
    return newcolor
#end parse_color_args

#+
# Drawing classes
#-

class Drawer :
#+
# Subclasses should define the following methods:
#
# opt_xxx
#     defines a command-line option xxx (for whatever xxx you like) to be specified
#     following the drawtype. Can take one or no arguments.
#
# setsize(w, h)
#     sets the dimensions of the drawing area.
#
# bgcolor(c)
#     clears the background to the specified colour. See pencolor, below, for valid
#     values for c.
#
# donesetup()
#     will be called exactly once. Indicates that no further calls to setsize or
#     bgcolor will be done.
#
# pensize(w)
#     sets the pensize for subsequent drawing to w.
#
# pencolor(c)
#     sets the pen colour for subsequent to c, which can be an X11 colour name, or a tuple
#     of 3 values (r, g, b) in [0 .. 1], or 3 separate args r, g, b in [0 .. 1].
#
# penup()
#     stops subsequent pen movements from drawing any lines.
#
# pendown()
#     resumes drawing lines on subsequent pen movements.
#
# setpos(p)
#     moves the pen to the specified position, which can be a Vector, or 2 separate x and y
#     arguments.
#
# close()
#     closes the current curve by adding a segment from the end point back to the
#     start point.
#
# done()
#     called at the end of drawing.
#-
    pass

#end Drawer

class CairoDrawer(Drawer) :
    "does drawing using Cairo graphics <http://cairographics.org/> via the" \
    " Qahirah wrapper <https://github.com/ldo/qahirah>."

    def __init__(self) :
        self.size = None
        self.bg_color = Colour.grey(1)
        self.pen_color = Colour.grey(0)
        self.pen_size = 1
        self.scale_factor = 1.0
        self.outfilename = None
    #end __init__

    def opt_out(self, filename) :
        self.outfilename = filename
    #end opt_out

    def opt_scale(self, factor) :
        self.scale_factor = float(factor)
    #end opt_scale

    def setsize(self, newsize) :
        self.size = Vector.from_tuple(newsize)
    #end setsize

    def bgcolor(self, *args) :
        self.bg_color = Colour.from_rgba(parse_color_args(args))
    #end bgcolor

    def donesetup(self) :
        assert self.size != None, "forgot to set drawing size"
        assert self.outfilename != None, "forgot to set output filename"
        self.pix = qah.ImageSurface.create \
          (
            format = CAIRO.FORMAT_RGB24,
            dimensions = self.size
          )
        self.g = \
            (qah.Context.create(self.pix)
                .set_operator(CAIRO.OPERATOR_SOURCE)
                .translate(self.size / 2)
                .scale((self.scale_factor, self.scale_factor))
                .set_source_colour(self.bg_color)
                .paint()
                .new_path()
                .move_to((0, 0))
            )
        self.inpath = True
        self.drawing = True
    #end donesetup

    def pensize(self, newsize) :
        self.pen_size = newsize
    #end pensize

    def pencolor(self, *args) :
        self.pen_color = Colour.from_rgba(parse_color_args(args))
    #end pencolor

    def penup(self) :
        self.finishpath()
        self.drawing = False
    #end penup

    def pendown(self) :
        self.drawing = True
    #end pendown

    def setpos(self, newpos) :
        self.startpath()
        (self.g.move_to, self.g.line_to)[self.drawing](newpos)
    #end setpos

    def close(self) :
        self.g.close_path()
    #end close

    def startpath(self) :
        if not self.inpath :
            (self.g
                .new_path()
                .set_source_colour(Colour.from_rgba(self.pen_color))
                .set_line_width(self.pen_size)
            )
            self.inpath = True
        #end if
    #end startpath

    def finishpath(self) :
        if self.inpath :
            self.g.stroke()
        #end if
        self.inpath = False
    #end finishpath

    def done(self) :
        self.finishpath()
        self.pix.flush()
        self.g = None
        self.pix.write_to_png(self.outfilename)
        self.pix = None
    #end done

#end CairoDrawer

class PostScriptDrawer(Drawer) :
    "outputs PostScript <https://en.wikipedia.org/wiki/PostScript> drawing commands."

    def __init__(self) :
        self.w = sys.stdout.write
        self.out = None
        self.nrpoints = 0
        self.drawing = True
        self.currentpoint = None
    #end __init__

    def opt_scale(self, factor) :
        factor = float(factor)
        self.w("%.3f %.3f scale\n" % (factor, factor))
    #end opt_scale

    def opt_out(self, filename) :
        self.out = open(filename, "w")
        self.w = self.out.write
    #end opt_out

    def setsize(self, newsize) :
        self.w \
          (
                "<<\n"
                "    /ImageBBox 0 0 %(width).3f %(height).3f\n"
                "    /PageSize %(width).3f %(height).3f\n"
                ">> setpagedevice\n"
            %
                {"width" : newsize[0], "height" : newsize[1]}
          )
    #end setsize

    def bgcolor(self, *args) :
        self.w("currentcolor currentcolorspace\n")
        self.w("%.3f %.3f %.3f setrgbcolor\n" % parse_color_args(args))
        self.w("clippath fill\nsetcolorspace setcolor\n")
    #end bgcolor

    def donesetup(self) :
        self.w \
          (
            "clippath pathbbox\n"
            "exch 4 3 roll sub 2 div\n" # x offset
            "3 1 roll exch sub 2 div\n" # y offset
            "translate\n" # move origin to centre
          )
    #end donesetup

    def pensize(self, newsize) :
        self.finishpath()
        self.w("%.1f setlinewidth\n" % newsize)
    #end pensize

    def pencolor(self, *args) :
        self.finishpath()
        self.w("%.3f %.3f %.3f setrgbcolor\n" % parse_color_args(args))
    #end pencolor

    def penup(self) :
        self.finishpath()
        self.drawing = False
    #end penup

    def pendown(self) :
        self.drawing = True
    #end pendown

    def setpos(self, newpos) :
        x, y = newpos[0], newpos[1]
        if self.nrpoints == 500 : # actually level 2 and later have no limit?
            self.finishpath()
        #end if
        if self.nrpoints == 0 :
            self.w("newpath\n")
            if self.drawing :
                if self.currentpoint == None :
                    self.w("0 0 moveto\n")
                else :
                    self.w("%.1f %.1f moveto\n" % (self.currentpoint[0], self.currentpoint[1]))
                #end if
            #end if
        #end if
        self.w("%.1f %.1f %s\n" % (x, y, ("moveto", "lineto")[self.drawing]))
        self.nrpoints += 1
        self.currentpoint = Vector(x, y)
    #end setpos

    def close(self) :
        self.w("closepath\n")
    #end close

    def finishpath(self) :
        if self.nrpoints != 0 :
            self.w("stroke\n")
            self.nrpoints = 0
        #end if
    #end finishpath

    def done(self) :
        self.finishpath()
        self.w("showpage\n")
        if self.out != None :
            self.out.flush()
            self.out.close()
        #end if
    #end done

#end PostScriptDrawer

class TurtleDrawer(Drawer) :
    "does the drawing on-screen using the Turtle Graphics" \
    " <https://docs.python.org/3/library/turtle.html> module."

    def __init__(self) :
        import turtle
        self.t = turtle
        for \
            method \
        in \
            ("bgcolor", "pensize", "pencolor", "pendown",) \
        :
            setattr(self, method, getattr(self.t, method))
        #end for
        self.track_heading = False
        self.first_point = None
        self.default_delay = self.t.delay()
    #end __init__

    def opt_speed(self, newspeed) :
        self.t.tracer(1, round(self.default_delay / float(newspeed)))
          # setting the first arg to anything other than 1 causes the whole
          # drawing to update instantly, so I change only the second arg
          # for nice speed control
    #end opt_speed

    def opt_hideturtle(self) :
        self.t.hideturtle()
    #end opt_hideturtle

    def opt_trackheading(self) :
        self.track_heading = True
    #end opt_trackheading

    def setsize(self, newsize) :
        w, h = newsize[0], newsize[1]
        self.t.screensize(w, h)
        self.t.setup(width = w, height = h)
    #end setsize

    def donesetup(self) :
        pass
    #end donesetup

    def penup(self) :
        self.t.penup()
        self.first_point = None
    #end penup

    def setpos(self, newpos) :
        if self.first_point == None and self.t.isdown() :
            self.first_point = self.t.position()
        #end if
        if self.track_heading and self.t.isvisible() :
            prevpos = self.t.position()
            self.t.setheading \
              (
                math.degrees(math.atan2(newpos[1] - prevpos[1], newpos[0] - prevpos[0]))
              )
        #end if
        self.t.setpos(newpos)
    #end setpos

    def close(self) :
        if self.first_point != None and self.t.isdown() :
            self.t.setpos(self.first_point)
        #end if
    #end close

    def done(self) :
        self.t.hideturtle()
        self.t.exitonclick()
    #end done

#end TurtleDrawer

drawtypes = \
    {
        "cairo" : CairoDrawer,
        "postscript" : PostScriptDrawer,
        "turtle" : TurtleDrawer,
    }

def draw_curve(d, c, nr_steps) :
    "d is a Drawer instance, c is a Curve instance, and nr_steps is the" \
    " number of straight-line segments to approximate the curve."
    if hasattr(c, "subcurve_func") :
        subcurve_func = c.subcurve_func
    else :
        subcurve_func = lambda t : 0
    #end if
    last_subcurve = None
    for i in range(0, nr_steps) :
        t = i / nr_steps
        subcurve = subcurve_func(t)
        if subcurve != last_subcurve :
            d.penup()
            last_subcurve = subcurve
        #end if
        d.setpos(c.curve_func(t))
        d.pendown() # for subsequent points
    #end for
    if c.closed :
        d.close()
    #end if
#end draw_curve

#+
# Curve classes
#-

class Curve :
#+
# Subclasses should define the following members:
#
# params
#     a dict mapping attribute names to functions that will convert strings
#     to suitable values for those attributes. If an attribute is initialized
#     to some value in the __init__ method, then specifying a value for that
#     attribute is optional; otherwise, it is mandatory.
#
# closed
#     whether the curve is closed.
#
# nr_steps
#     optional, indicates the curve is not really a curve, but is made of the
#     specified number of straight-line segments. Typically will be a property
#     that needs to be computed from the given curve parameters.
#
# setup()
#     optional, if present, will be called after setting of all options and before
#     first call to curve_func.
#
# curve_func(t)
#     maps a parameter value t ∈ [0, 1) onto a corresponding (x, y) coordinate tuple
#     for defining the curve.
#
# subcurve_func(t)
#     optional, returns an integer which, when it changes from the previous value,
#     indicates that a new subcurve is starting which should not be joined to the
#     previous one.
#-

    pass
#end Curve

class LissaCurve(Curve) :
    "draws a Lissajous curve. For background, see <https://en.wikipedia.org/wiki/Lissajous_curve>."

    closed = True
    params = \
        {
            "x_amp" : float, # amplitude of curve along x-axis
            "x_freq" : int, # frequency of curve along x-axis
            "x_phase" : float, # phase of curve along x-axis
            "y_amp" : float, # amplitude of curve along y-axis
            "y_freq" : int, # frequency of curve along y-axis
            "y_phase" : float, # phase of curve along y-axis
        }

    def __init__(self) :
        self.x_phase = 0
        self.y_phase = 0
    #end __init__

    def setup(self) :
        # reduce relative frequencies to lowest terms
        freq_ratio = Fraction(self.x_freq, self.y_freq)
        self.x_freq, self.y_freq = freq_ratio.numerator, freq_ratio.denominator
    #end setup

    def curve_func(self, t) :
        return \
            (
                math.sin((t + self.x_phase) * 2 * math.pi * self.x_freq) * self.x_amp,
                math.sin((t + self.y_phase) * 2 * math.pi * self.y_freq) * self.y_amp,
            )
    #end curve_func

#end LissaCurve

class MaurerCurve(Curve) :
    "draws a Maurer rose curve. For background, see" \
    " Peter M Maurer, “A Rose is a Rose...”" \
    " <http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.97.8141&rep=rep1&type=pdf>."

    closed = True
    params = \
        {
            "amplitude" : float, # amplitude of sine wave
            "delta" : int, # the number of steps between successive curve points
            "mod" : int, # modulus (total number of steps around curve)
            "freq" : int,
            "offset" : float, # offset of curve, defaults to 0
            "phase" : float, # phase angle for rotating curve
        }

    def __init__(self) :
        self.offset = 0
        self.phase = 0
    #end __init__

    def setup(self) :
        self.k = gcd(self.delta, self.mod)
    #end setup

    @property
    def nr_steps(self) :
        return \
            self.mod
    #end nr_steps

    if False :

        def subcurve_func(self, t) :
            return \
                math.floor(t * self.k)
        #end subcurve_func

    #end if

    def curve_func(self, t) :
        subcurve = math.floor(t * self.k)
        step = round((t * self.delta - subcurve) * self.mod) % self.mod
        phi = 2 * math.pi * (step + subcurve) / self.mod
        theta = 2 * math.pi * ((step + subcurve) * self.freq / self.mod + self.phase)
        r = self.offset + math.sin(theta) * self.amplitude
        return \
            (r * math.cos(phi), r * math.sin(phi))
    #end curve_func

#end MaurerCurve

class RoseCurve(Curve) :
    "draws a rose curve. For background, see <<https://en.wikipedia.org/wiki/Rose_curve>."

    closed = True
    params = \
        {
            "amplitude" : float, # amplitude of sine wave
            "freq" : parse_ratio, #  frequency
            "offset" : float, # offset of curve, defaults to 0
            "phase" : float, # phase angle for rotating curve
        }

    def __init__(self) :
        self.offset = 0
        self.phase = 0
    #end __init__

    def curve_func(self, t) :
        # Note that the curve can still be traced twice in some situations, namely where
        # the frequency numerator and denominator are both odd, and the offset is zero.
        # But if the offset is set to nonzero, the two halves no longer overlap.
        phi = 2 * math.pi * t * self.freq.denominator
        theta = 2 * math.pi * (t + self.phase) * self.freq.numerator
        r = self.offset + math.sin(theta) * self.amplitude
        return \
            (r * math.cos(phi), r * math.sin(phi))
    #end curve_func

#end RoseCurve

class TrochCurve(Curve) :
    "draws a hypotrochoid or epitrochoid curve. For background, see" \
    " <https://en.wikipedia.org/wiki/Spirograph>, <https://en.wikipedia.org/wiki/Epitrochoid>" \
    " and <https://en.wikipedia.org/wiki/Hypotrochoid>."

    closed = True
    params = \
        {
            "ring" : int, # radius of stationary ring
            "wheel" : int, # radius of moving wheel
            "scale" : float,
              # scale factor applied to ring and wheel radius, allowing
              # small integers to be used for above to make their relative
              # factors more obvious
            "frac" : float, # fraction of wheel radius from centre for location of curve point
            "phase" : float, # phase angle for rotating entire curve
        }

    def __init__(self) :
        self.scale = 1
        self.phase = 0
    #end __init__

    def setup(self) :
        ratio = Fraction(self.ring, self.wheel)
        self.nr_cycles = ratio.denominator # to produce one complete traversal of curve
    #end setup

    def curve_func(self, t) :
        theta_ring = 360 * self.nr_cycles * t
        theta_wheel = theta_ring * (self.ring / self.wheel + 1)
        wheel_pos = Vector((self.ring + self.wheel) * self.scale, 0).rotate((theta_ring + self.phase) * qah.deg)
        curve_pos = wheel_pos + Vector(self.wheel * self.scale * self.frac, 0).rotate(theta_wheel * qah.deg)
        return \
            tuple(curve_pos)
    #end curve_func

#end TrochCurve

curvetypes = \
    {
        "lissa" : LissaCurve,
        "maurer" : MaurerCurve,
        "rose" : RoseCurve,
        "troch" : TrochCurve,
    }

#+
# Mainline
#-

(opts, args) = getopt.getopt \
  (
    sys.argv[1:],
    "",
    ["bgcolor=", "bgcolour=", "draw=", "nrsteps=", "size="]
  )
drawtype = None
bgcolor = None
drawsize = None
default_nrsteps = None
for keyword, value in opts :
    if keyword == "--bgcolor" or keyword == "--bgcolour" :
        bgcolor = parse_color_opt(value)
    elif keyword == "--draw" :
        items = value.split(":")
        if drawtype != None :
            raise getopt.GetoptError("only one --draw opt allowed")
        #end if
        drawtype = drawtypes[items[0]]
        d = drawtype()
        for item in items[1:] :
            value = item.split("=", 1)
            if len(value) == 2 :
                keyword, optargs = value[0], (value[1],)
            else :
                keyword, optargs = value[0], ()
            #end if
            opt_method = "opt_" + keyword
            assert hasattr(d, opt_method), "%s drawtype has no option %s" % (items[0], keyword)
            getattr(d, opt_method)(*optargs)
        #end for
    elif keyword == "--nrsteps" :
        default_nrsteps = int(value)
    elif keyword == "--size" :
        items = value.split(":", 1)
        assert len(items) == 2, "--size must be h:w"
        drawsize = Vector(int(items[0]), int(items[1]))
    #end if
#end for
if drawtype == None :
    raise getopt.GetoptError("missing --draw opt")
#end if
if drawsize != None :
    d.setsize(drawsize)
#end if
if bgcolor != None :
    d.bgcolor(bgcolor)
#end if
d.donesetup()
curvename = None
for arg in args :
    # note pen_color and pen_size default to settings for previous curve, if any
    pen_color = None
    pen_size = None
    items = arg.split(":")
    if len(items) == 0 :
        raise getopt.GetoptError("missing curve type")
    #end if
    if curvename == None or len(items[0]) != 0 :
        curvename = items[0]
        curve = curvetypes[curvename]()
        nr_steps = default_nrsteps
    #end if
    items = items[1:]
    for item in items :
        parts = item.split("=", 1)
        assert len(parts) == 2, "param must have form keyword=value: %s" % item
        keyword, value = parts
        if keyword == "nrsteps" :
            assert not hasattr(curve, "nr_steps"), "curve provides its own value for nrsteps"
            nr_steps = int(value)
        elif keyword == "pencolor" or keyword == "pencolour" :
            pen_color = parse_color_opt(value)
        elif keyword == "pensize" :
            pen_size = float(value)
        elif keyword in curve.params :
            setattr(curve, keyword, curve.params[keyword](value))
        else :
            raise getopt.GetoptError("no such curve param %s" % keyword)
        #end if
    #end for
    missing = set \
      (
        keyword for keyword in curve.params if not hasattr(curve, keyword)
      )
    if len(missing) != 0 :
        raise getopt.GetoptError \
          (
            "missing parameters for %s curve: %s" % (curvename, ", ".join(tuple(missing)))
          )
    #end if
    if hasattr(curve, "nr_steps") :
        nr_steps = curve.nr_steps
    #end if
    if nr_steps == None :
        raise getopt.GetoptError("forgot to specify nrsteps")
    #end if
    if pen_color != None :
        d.pencolor(pen_color)
    #end if
    if pen_size != None :
        d.pensize(pen_size)
    #end if
    if hasattr(curve, "setup") :
        curve.setup()
    #end if
    draw_curve(d, curve, nr_steps)
#end for
d.done()
